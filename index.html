<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>前端圈</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="前端圈">
<meta property="og:url" content="https://lizheguang.github.io/index.html">
<meta property="og:site_name" content="前端圈">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="前端圈" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">前端圈</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://lizheguang.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/15/hello-world/" class="article-date">
  <time datetime="2019-02-15T04:17:08.000Z" itemprop="datePublished">2019-02-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/02/15/hello-world/">类数组对象</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="类数组对象"><a href="#类数组对象" class="headerlink" title="类数组对象"></a>类数组对象</h1><p><strong>故事要从一行代码说起</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr[0]</span><br><span class="line">&#x2F;&#x2F; &#39;tom&#39;</span><br></pre></td></tr></table></figure>

<p>请问这里的 arr 一定是一个数组吗？非也，它也可能是一个对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let arr &#x3D; &#123;</span><br><span class="line">  0: &#39;tom&#39;</span><br><span class="line">&#125;</span><br><span class="line">arr[0]</span><br><span class="line">&#x2F;&#x2F; &#39;tom&#39;</span><br></pre></td></tr></table></figure>

<p>前面我们讲过 <strong>arguments</strong> 这个对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let say &#x3D; function ()&#123;</span><br><span class="line">	console.log(arguments)</span><br><span class="line">&#125;</span><br><span class="line">say(1,2)</span><br></pre></td></tr></table></figure>

<p>其大致结构如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0: 1</span><br><span class="line">1: 2</span><br><span class="line">length: 2</span><br></pre></td></tr></table></figure>

<p>我们称 arguments 为类数组对象，正是因为它有这个 length 属性，虽然不能用数组的方法，但是可以通过索引来访问，而且还可以将其转换成数组。</p>
<p>如果一个普通的对象加上一个 length 属性就可以变成一个类数组对象。</p>
<p>之所以今天要讲这个类数组对象，是因为 JavaScirpt 中有很多方法和处理跟类数组对象有关系，所以我们有必要搞清楚这个概念。</p>
<h3 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h3><p>ES6 的 Array.from() 可以将一个类数组对象转成数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let say &#x3D; function () &#123;</span><br><span class="line">  console.log(Array.from(arguments))</span><br><span class="line">&#125;</span><br><span class="line">say(1, 2)</span><br><span class="line">&#x2F;&#x2F; [1, 2]</span><br></pre></td></tr></table></figure>

<p>当然也可以用 ES5 的 slice</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.slice.call(arguments)</span><br></pre></td></tr></table></figure>

<p>接下来我们自己起来创建一个类数组对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let mans &#x3D; &#123;</span><br><span class="line">  0: &#39;tom&#39;,</span><br><span class="line">  1: &#39;lucy&#39;,</span><br><span class="line">  length: 2</span><br><span class="line">&#125;</span><br><span class="line">Array.from(mans)</span><br><span class="line">&#x2F;&#x2F; [&quot;tom&quot;, &quot;lucy&quot;]</span><br></pre></td></tr></table></figure>

<p>如果 length 值和实际元素不相等呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let mans &#x3D; &#123;</span><br><span class="line">  0: &#39;tom&#39;,</span><br><span class="line">  length: 2</span><br><span class="line">&#125;</span><br><span class="line">Array.from(mans)</span><br><span class="line">&#x2F;&#x2F; [&quot;tom&quot;, undefined]</span><br></pre></td></tr></table></figure>

<p>可以看到，如果 length 值大于实际元素的数量，不足的将用 undefined 填充，那么反过来呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let mans &#x3D; &#123;</span><br><span class="line">  0: &#39;tom&#39;,</span><br><span class="line">  1: &#39;lucy&#39;,</span><br><span class="line">  length: 1</span><br><span class="line">&#125;</span><br><span class="line">Array.from(mans)</span><br><span class="line">&#x2F;&#x2F; [&quot;tom&quot;]</span><br></pre></td></tr></table></figure>
<p>可见，length 值是决定最终生成数组的长度的，多余的去掉，不足的用 undefined 补齐。好奇心驱使我们继续探索，0 和 1 这两个索引真的有用吗？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mans &#x3D; &#123;</span><br><span class="line">  3: &#39;tom&#39;,</span><br><span class="line">  1: &#39;lucy&#39;,</span><br><span class="line">  length: 2</span><br><span class="line">&#125;</span><br><span class="line">Array.from(mans)</span><br><span class="line">&#x2F;&#x2F; [undefined, &quot;lucy&quot;]</span><br></pre></td></tr></table></figure>

<p>所以，这个值是真的有用的，决定了最终的填充索引。细心的同学可能会记得，还有另外一个转换 arguments 的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[...arguments]</span><br></pre></td></tr></table></figure>
<p>那么这个展开运算符可以用到普通的类数组对象上吗？还是亲自测试一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let mans &#x3D; &#123;</span><br><span class="line">  0: &#39;tom&#39;,</span><br><span class="line">  1: &#39;lucy&#39;,</span><br><span class="line">  length: 2</span><br><span class="line">&#125;;</span><br><span class="line">[...mans]</span><br><span class="line">&#x2F;&#x2F; Uncaught TypeError: mans is not iterable</span><br></pre></td></tr></table></figure>

<p>可以看到报错了，mans 不是可迭代的，也就证实了 arguments 除了是类数组对象，还是一个可迭代对象，而我们自定义的对象并不具备可迭代功能，所以不能使用展开运算符。</p>
<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>因为有 length 属性，所以我们可以用 for 循环进行遍历</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let mans &#x3D; &#123;</span><br><span class="line">  0: &#39;tom&#39;,</span><br><span class="line">  1: &#39;lucy&#39;,</span><br><span class="line">  length: 2</span><br><span class="line">&#125;;</span><br><span class="line">for (let i &#x3D; 0; i &lt; mans.length; i++) &#123;</span><br><span class="line">  console.log(i)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 0</span><br><span class="line">&#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure>

<p>除了传统的 for 循环，其它遍历方法可以使用吗？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mans.forEach(item &#x3D;&gt; &#123;</span><br><span class="line">  console.log(item)</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F; mans.forEach is not a function</span><br></pre></td></tr></table></figure>

<p>因为 forEach 是数组的一个方法，只能用于数组，自然就不能用在类数组对象身上了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (let man of mans) &#123;</span><br><span class="line">  console.log(man)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; mans is not iterable</span><br></pre></td></tr></table></figure>

<p>因为 for…of 也是需要应用到可迭代对象上的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (let index in mans) &#123;</span><br><span class="line">  console.log(index)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 0</span><br><span class="line">&#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure>

<p>所以只有 for 和 for…in 可以用来遍历类数组对象。</p>
<p>检测</p>
<p>除了 arguments，DOM 元素节点集合也是一个类数组对象，打开任意一个网页，F12 输入下面的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.getElementsByTagName(&#39;div&#39;)</span><br></pre></td></tr></table></figure>

<p>可以看到里面有 length 属性，的确是类数组的结构，Array 也有 length 属性，难道这就不会是一个真的数组吗？</p>
<p>倒也是，这个时候就需要利用我们前面讲过的检测数组的方法了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.toString.call(document.getElementsByTagName(&#39;div&#39;))</span><br><span class="line">&#x2F;&#x2F; [object HTMLCollection]</span><br></pre></td></tr></table></figure>

<p>可以看到这确实不是一个数组。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://lizheguang.github.io/2019/02/15/hello-world/" data-id="ckcjwfluv00000f97b68xhy6y" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-TCP三次握手与四次握手" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/15/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B/" class="article-date">
  <time datetime="2019-02-15T04:17:08.000Z" itemprop="datePublished">2019-02-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/02/15/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B/">TCP三次握手与四次握手</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- toc -->

<h2 id="TCP三次握手与四次握手"><a href="#TCP三次握手与四次握手" class="headerlink" title="TCP三次握手与四次握手"></a>TCP三次握手与四次握手</h2><h3 id="什么是三次握手？"><a href="#什么是三次握手？" class="headerlink" title="什么是三次握手？"></a>什么是三次握手？</h3><p>所谓三次握手，是指建立一个TCP连接时，需要客户端和服务器总共发送3个包</p>
<p>三次握手的目的是建立可靠的通信信道，简单来说就是数据的发送与接收。</p>
<h4 id="为什么要三次握手？"><a href="#为什么要三次握手？" class="headerlink" title="为什么要三次握手？"></a>为什么要三次握手？</h4><p>三次握手最主要的目的就是双方确认自己与对方的发送与接收机能正常</p>
<p><strong>三次握手的过程</strong></p>
<ol>
<li>第一次握手：client什么都不能确认；server确认了对方发送正常</li>
<li>第二次握手：client确认了：自己发送，接收正常，对方发送，接收正常；server确认了：自己接收正常，对方发送正常</li>
<li>第三次握手：client确认了：自己发送，接收正常，对方发送，接收正常；server确认了：自己发送，接收正常，对方发送接收正常。</li>
</ol>
<p>所以三次握手，就能确认双方，收发功能都正常。</p>
<p>整个三次握手，其实就是为了验证彼此是否接收都正常</p>
<hr>
<h3 id="什么是四次挥手？"><a href="#什么是四次挥手？" class="headerlink" title="什么是四次挥手？"></a>什么是四次挥手？</h3><p>假设Client端发起中断连接请求，也就是发送FIN报文。</p>
<p>Server端接到FIN报文后，意思是说”我Client端没有数据要发给你了”，但是如果你还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。</p>
<p>所以你先发送ACK，”告诉Client端，你的请求我收到了，但是我还没准备好，请继续你等我的消息”。</p>
<p>这个时候Client端就进入FIN_WAIT状态，继续等待Server端的FIN报文。当Server端确定数据已发送完成，则向Client端发送FIN报文，”告诉Client端，好了，我这边数据发完了，准备好关闭连接了”。</p>
<p>Client端收到FIN报文后，”就知道可以关闭连接了，但是他还是不相信网络，怕Server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。“，Server端收到ACK后，”就知道可以断开连接了”。</p>
<p>Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了。Ok，TCP连接就这样关闭了！</p>
<h4 id="为什么要四次挥手？"><a href="#为什么要四次挥手？" class="headerlink" title="为什么要四次挥手？"></a>为什么要四次挥手？</h4><p>一方发送FIN只表示自己发完了所有要发的数据，但还允许对方继续把没发完的数据发过来。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://lizheguang.github.io/2019/02/15/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B/" data-id="ckcjwflv600010f976kqwc0ic" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-类数组对象" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/15/%E7%B1%BB%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1/" class="article-date">
  <time datetime="2019-02-15T04:17:08.000Z" itemprop="datePublished">2019-02-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/02/15/%E7%B1%BB%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1/">类数组对象</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="类数组对象"><a href="#类数组对象" class="headerlink" title="类数组对象"></a>类数组对象</h1><p><strong>故事要从一行代码说起</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr[0]</span><br><span class="line">&#x2F;&#x2F; &#39;tom&#39;</span><br></pre></td></tr></table></figure>

<p>请问这里的 arr 一定是一个数组吗？非也，它也可能是一个对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let arr &#x3D; &#123;</span><br><span class="line">  0: &#39;tom&#39;</span><br><span class="line">&#125;</span><br><span class="line">arr[0]</span><br><span class="line">&#x2F;&#x2F; &#39;tom&#39;</span><br></pre></td></tr></table></figure>

<p>前面我们讲过 <strong>arguments</strong> 这个对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let say &#x3D; function ()&#123;</span><br><span class="line">	console.log(arguments)</span><br><span class="line">&#125;</span><br><span class="line">say(1,2)</span><br></pre></td></tr></table></figure>

<p>其大致结构如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0: 1</span><br><span class="line">1: 2</span><br><span class="line">length: 2</span><br></pre></td></tr></table></figure>

<p>我们称 arguments 为类数组对象，正是因为它有这个 length 属性，虽然不能用数组的方法，但是可以通过索引来访问，而且还可以将其转换成数组。</p>
<p>如果一个普通的对象加上一个 length 属性就可以变成一个类数组对象。</p>
<p>之所以今天要讲这个类数组对象，是因为 JavaScirpt 中有很多方法和处理跟类数组对象有关系，所以我们有必要搞清楚这个概念。</p>
<h3 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h3><p>ES6 的 Array.from() 可以将一个类数组对象转成数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let say &#x3D; function () &#123;</span><br><span class="line">  console.log(Array.from(arguments))</span><br><span class="line">&#125;</span><br><span class="line">say(1, 2)</span><br><span class="line">&#x2F;&#x2F; [1, 2]</span><br></pre></td></tr></table></figure>

<p>当然也可以用 ES5 的 slice</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.slice.call(arguments)</span><br></pre></td></tr></table></figure>

<p>接下来我们自己起来创建一个类数组对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let mans &#x3D; &#123;</span><br><span class="line">  0: &#39;tom&#39;,</span><br><span class="line">  1: &#39;lucy&#39;,</span><br><span class="line">  length: 2</span><br><span class="line">&#125;</span><br><span class="line">Array.from(mans)</span><br><span class="line">&#x2F;&#x2F; [&quot;tom&quot;, &quot;lucy&quot;]</span><br></pre></td></tr></table></figure>

<p>如果 length 值和实际元素不相等呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let mans &#x3D; &#123;</span><br><span class="line">  0: &#39;tom&#39;,</span><br><span class="line">  length: 2</span><br><span class="line">&#125;</span><br><span class="line">Array.from(mans)</span><br><span class="line">&#x2F;&#x2F; [&quot;tom&quot;, undefined]</span><br></pre></td></tr></table></figure>

<p>可以看到，如果 length 值大于实际元素的数量，不足的将用 undefined 填充，那么反过来呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let mans &#x3D; &#123;</span><br><span class="line">  0: &#39;tom&#39;,</span><br><span class="line">  1: &#39;lucy&#39;,</span><br><span class="line">  length: 1</span><br><span class="line">&#125;</span><br><span class="line">Array.from(mans)</span><br><span class="line">&#x2F;&#x2F; [&quot;tom&quot;]</span><br></pre></td></tr></table></figure>
<p>可见，length 值是决定最终生成数组的长度的，多余的去掉，不足的用 undefined 补齐。好奇心驱使我们继续探索，0 和 1 这两个索引真的有用吗？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mans &#x3D; &#123;</span><br><span class="line">  3: &#39;tom&#39;,</span><br><span class="line">  1: &#39;lucy&#39;,</span><br><span class="line">  length: 2</span><br><span class="line">&#125;</span><br><span class="line">Array.from(mans)</span><br><span class="line">&#x2F;&#x2F; [undefined, &quot;lucy&quot;]</span><br></pre></td></tr></table></figure>

<p>所以，这个值是真的有用的，决定了最终的填充索引。细心的同学可能会记得，还有另外一个转换 arguments 的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[...arguments]</span><br></pre></td></tr></table></figure>
<p>那么这个展开运算符可以用到普通的类数组对象上吗？还是亲自测试一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let mans &#x3D; &#123;</span><br><span class="line">  0: &#39;tom&#39;,</span><br><span class="line">  1: &#39;lucy&#39;,</span><br><span class="line">  length: 2</span><br><span class="line">&#125;;</span><br><span class="line">[...mans]</span><br><span class="line">&#x2F;&#x2F; Uncaught TypeError: mans is not iterable</span><br></pre></td></tr></table></figure>

<p>可以看到报错了，mans 不是可迭代的，也就证实了 arguments 除了是类数组对象，还是一个可迭代对象，而我们自定义的对象并不具备可迭代功能，所以不能使用展开运算符。</p>
<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>因为有 length 属性，所以我们可以用 for 循环进行遍历</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let mans &#x3D; &#123;</span><br><span class="line">  0: &#39;tom&#39;,</span><br><span class="line">  1: &#39;lucy&#39;,</span><br><span class="line">  length: 2</span><br><span class="line">&#125;;</span><br><span class="line">for (let i &#x3D; 0; i &lt; mans.length; i++) &#123;</span><br><span class="line">  console.log(i)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 0</span><br><span class="line">&#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure>

<p>除了传统的 for 循环，其它遍历方法可以使用吗？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mans.forEach(item &#x3D;&gt; &#123;</span><br><span class="line">  console.log(item)</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F; mans.forEach is not a function</span><br></pre></td></tr></table></figure>

<p>因为 forEach 是数组的一个方法，只能用于数组，自然就不能用在类数组对象身上了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (let man of mans) &#123;</span><br><span class="line">  console.log(man)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; mans is not iterable</span><br></pre></td></tr></table></figure>

<p>因为 for…of 也是需要应用到可迭代对象上的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (let index in mans) &#123;</span><br><span class="line">  console.log(index)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 0</span><br><span class="line">&#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure>

<p>所以只有 for 和 for…in 可以用来遍历类数组对象。</p>
<p>检测</p>
<p>除了 arguments，DOM 元素节点集合也是一个类数组对象，打开任意一个网页，F12 输入下面的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.getElementsByTagName(&#39;div&#39;)</span><br></pre></td></tr></table></figure>

<p>可以看到里面有 length 属性，的确是类数组的结构，Array 也有 length 属性，难道这就不会是一个真的数组吗？</p>
<p>倒也是，这个时候就需要利用我们前面讲过的检测数组的方法了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.toString.call(document.getElementsByTagName(&#39;div&#39;))</span><br><span class="line">&#x2F;&#x2F; [object HTMLCollection]</span><br></pre></td></tr></table></figure>

<p>可以看到这确实不是一个数组。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://lizheguang.github.io/2019/02/15/%E7%B1%BB%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1/" data-id="ckcjwflvg000a0f9709z35hv2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="[layout]-node面试" class="article article-type-[layout]" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/17/node%E9%9D%A2%E8%AF%95/" class="article-date">
  <time datetime="2018-12-17T06:29:12.000Z" itemprop="datePublished">2018-12-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/17/node%E9%9D%A2%E8%AF%95/">node面试</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="nodeJS常见问题"><a href="#nodeJS常见问题" class="headerlink" title="nodeJS常见问题"></a>nodeJS常见问题</h3><!-- toc -->

<ul>
<li>node的特点<ul>
<li>异步IO</li>
<li>单线程</li>
<li>跨平台</li>
<li>前后端编程语言的统一</li>
<li>工具类应用</li>
</ul>
</li>
<li>单线程的缺点<ul>
<li>无法利用多核CPU</li>
<li>错误会引起整个应用的退出</li>
<li>大量计算占用CPU无法继续调用异步IO</li>
<li>解决方案：<ul>
<li>node提供了子进程的概念</li>
</ul>
</li>
</ul>
</li>
<li>对于javascript自身而言，它的规范依然包若，还有以下的缺陷<ul>
<li>没有模块系统</li>
<li>标准库较少</li>
<li>没有标准接口</li>
<li>缺乏包管理系统</li>
</ul>
</li>
</ul>
<hr>
<h3 id="为什么javaScript是单线程"><a href="#为什么javaScript是单线程" class="headerlink" title="为什么javaScript是单线程"></a>为什么javaScript是单线程</h3><blockquote>
<p>js语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。<br>javascript的单线程，与他的用途有关，作为浏览器脚本语言，js的主要用途是用于交互，以及操作DOM元素。<br>这决定了他只能是单线程，否则，会带来很复杂的同步问题！<br>所以为了避免复杂性，js从一诞生，就是单线程，已经成了这门语言的核心特征。</p>
</blockquote>
<h3 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h3><p>主线程从”任务队列”中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）。</p>
<h3 id="Libuv"><a href="#Libuv" class="headerlink" title="Libuv"></a>Libuv</h3><p>什么是Libuv？Libuv是一个高性能的，事件驱动的I/O库，并且提供了 跨平台（如windows, nix）的API。简单的来说：<br><strong>Node.js的异步、非阻塞I/O，底层实际上是Libuv实现的</strong>。</p>
<h3 id="Node-的模块实现"><a href="#Node-的模块实现" class="headerlink" title="Node 的模块实现"></a>Node 的模块实现</h3><pre><code>Node在实现中并非完全按照实现，尽管规范中 exports,require和module 听起来十分简单，但是node在实现他们的过程中经历了。</code></pre><ul>
<li>在node中引入模块，需要经历如下3个步骤<ul>
<li>路径分析</li>
<li>文件定位</li>
<li>编译执行</li>
</ul>
</li>
<li>在node中，模块分为两类：一类是node提供的模块，称为核心模块；</li>
<li>另一类是用户编写的模块，称为文件模块</li>
<li>简洁以下 以上的问题<ul>
<li>核心模块（node自身的）</li>
<li>文件模块</li>
</ul>
</li>
</ul>
<p><strong>node 的模块会优先从缓存加载</strong></p>
<h4 id="NODE-js的运行机制"><a href="#NODE-js的运行机制" class="headerlink" title="NODE.js的运行机制"></a>NODE.js的运行机制</h4><ul>
<li>V8引擎解析Javascript脚本</li>
<li>解析后的代码，调用NODE API</li>
<li>libuv库负责Node API的执行。它将不同的任务分配给不同的线程，形成一个Event Loop（事件循环），以异步的方式将任务的执行结果返回给V8引擎。</li>
<li>V8引擎再将结果返回</li>
</ul>
<hr>
<h3 id="模块编译过程总结"><a href="#模块编译过程总结" class="headerlink" title="模块编译过程总结"></a>模块编译过程总结</h3><p><strong>核心模块编译过程中经过了头尾包装的过程</strong><br>有些模块是C++来编写，有些则是由C++完成核心部分，其他部分择优javascript实现包装或向外导出。</p>
<h4 id="内建模块的优势"><a href="#内建模块的优势" class="headerlink" title="内建模块的优势"></a>内建模块的优势</h4><ul>
<li>本身是由C/C++编写，性能上高于脚本语言</li>
<li>在文件被编译时，它被编译成二进制文件，一旦node执行，在直接被加载进内存中。</li>
</ul>
<h4 id="前后端模块的侧重点"><a href="#前后端模块的侧重点" class="headerlink" title="前后端模块的侧重点"></a>前后端模块的侧重点</h4><p><img src="evernotecid://EBC06249-D6A1-4732-BCC4-49915E428FC6/appyinxiangcom/12846741/ENResource/p188" alt="12078c89e5b5ad49eced67b3452b58fe.png"></p>
<p>前后端javascript分别搁置在HTTP的两端，它们扮演的角色并不同。浏览器端的Javascript需要经历从同一个服务器端分发到多个客户端执行，而服务端的javascript则是相同的代码多次执行，前者的瓶颈在于带宽，后者的瓶颈在于CPU和内存等资源。<br>前者需要通过网络加载代码，后者从磁盘中加载，两者的加载不在一个数量级上。</p>
<h3 id="异步IO小结"><a href="#异步IO小结" class="headerlink" title="异步IO小结"></a>异步IO小结</h3><p>从前面实现的异步IO过程描述中，我们可以提取出几个异步IO的关键字</p>
<ul>
<li>单线程</li>
<li>事件循环</li>
<li>观察者</li>
<li>IO线程池</li>
</ul>
<blockquote>
<p>在node中，除了JavaScript是单线程外，node自身其实是多线程<br>除了用户的代码无法并行执行外，所有的IO操作则是可以并行起来的</p>
</blockquote>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>   时间循环是异步实现的核心，它与浏览器中的执行模型基本保持了一致。</p>
<h3 id="NODE与v8"><a href="#NODE与v8" class="headerlink" title="NODE与v8"></a>NODE与v8</h3><p><img src="evernotecid://EBC06249-D6A1-4732-BCC4-49915E428FC6/appyinxiangcom/12846741/ENResource/p191" alt="5fcce6df68995159091d4b840a6c6d6b.png"></p>
<h4 id="v8的内存限制"><a href="#v8的内存限制" class="headerlink" title="v8的内存限制"></a>v8的内存限制</h4><ul>
<li>在node中通过javascript使用内存时，只能使用部分内存</li>
<li>64位操作系统 1.4GB</li>
<li>32位操作系统0.7gb</li>
<li>这导致node无法直接操作大内存对象</li>
<li>node在启动时，可以打开内存限制</li>
</ul>
<h3 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h3><blockquote>
<p>NODE提供了net,dgram,http,https 着4个模块，分别用于处理TCP,UDP,HTTP,HTTPS适用于服务端和客户端</p>
</blockquote>
<h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><p>TCP名为<strong>传输控制协议</strong>，在OSI模型（由七层组成，物理层，数据链结层，网络层，传输层，会话层，表示层，应用层）</p>
<p><img src="evernotecid://EBC06249-D6A1-4732-BCC4-49915E428FC6/appyinxiangcom/12846741/ENResource/p192" alt="58ef920c8d2d629beb347082b2913158.png"></p>
<p>TCP是面向连接的协议，最显著地特征就是需要<strong>三次握手</strong>形成会话，只有会话形成后，服务端与客户端才能进行互相的发送数据</p>
<h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><ul>
<li>用户服务异常</li>
<li>进程异常</li>
<li>服务器性能异常</li>
</ul>
<h3 id="事物（ACID）"><a href="#事物（ACID）" class="headerlink" title="事物（ACID）"></a>事物（ACID）</h3><h4 id="数据库事物的四大特性"><a href="#数据库事物的四大特性" class="headerlink" title="数据库事物的四大特性"></a>数据库事物的四大特性</h4><ul>
<li>原子性 atomicity<ul>
<li>原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚。</li>
<li>这样避免中间某一部分操作失败不会对数据库造成影响</li>
</ul>
</li>
<li>一致性 consistency<ul>
<li>事务执行之前和执行之后都必须处于一致性的状态</li>
<li>拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。</li>
</ul>
</li>
<li>隔离性 isolation<ul>
<li>隔离性是当多个用户并发访问数据库，操作数据库，比如操作同一张表，数据库为每个用户开启的事物，不能被其他事物打扰，多个并发事物之间相互隔离</li>
</ul>
</li>
<li>持久性 DURability<ul>
<li>持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</li>
</ul>
</li>
</ul>
<h4 id="事物"><a href="#事物" class="headerlink" title="事物"></a>事物</h4><ul>
<li>脏读<ul>
<li>服务A读取了事物B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据</li>
</ul>
</li>
<li>不可重复读<ul>
<li>事物 A 多次读取统一数据 事物 B 在事物A多次读取的过程中，对数据做了更新并提交，导致事物A多次读取统一数据时，结果不一致</li>
</ul>
</li>
<li>虚读<ul>
<li>系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。</li>
</ul>
</li>
</ul>
<h4 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h4><table>
<thead>
<tr>
<th>事物隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>读未提交</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>不可重复读</td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>可重复读</td>
<td>否</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>串行化</td>
<td>否</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>### mongoDb</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>mongodb在创建索引时，会自动给索引命名！</li>
<li>索引名字有长度限制 124字节</li>
</ul>
<h4 id="索引属性重要的有"><a href="#索引属性重要的有" class="headerlink" title="索引属性重要的有"></a>索引属性重要的有</h4><ul>
<li>名字</li>
<li>唯一性</li>
<li>稀疏性</li>
<li>是否定时删除</li>
</ul>
<h4 id="mongodb索引都有哪些？"><a href="#mongodb索引都有哪些？" class="headerlink" title="mongodb索引都有哪些？"></a>mongodb索引都有哪些？</h4><ul>
<li>_id索引</li>
<li>复合索引</li>
<li>过期索引</li>
<li>全文索引</li>
<li>地理空间索引</li>
</ul>
<h4 id="mongodb-索引分析"><a href="#mongodb-索引分析" class="headerlink" title="mongodb 索引分析"></a>mongodb 索引分析</h4><ul>
<li>mongoStat工具<ul>
<li>查看MongoDB运行状态的程序</li>
</ul>
</li>
<li>profile集合<ul>
<li>索引优点：加快索引相关的查询</li>
<li>索引缺点：增加磁盘空间消耗，降低写入性能<br><img src="evernotecid://EBC06249-D6A1-4732-BCC4-49915E428FC6/appyinxiangcom/12846741/ENResource/p193" alt="17112272248ef69d4bfb6face4b0738b.png"></li>
</ul>
</li>
</ul>
<h3 id="MongoDB安全概念"><a href="#MongoDB安全概念" class="headerlink" title="MongoDB安全概念"></a>MongoDB安全概念</h3><ul>
<li>最安全的是物理隔绝 ：不现实</li>
<li>网络隔离层 某些网络下可以</li>
<li>防火墙隔离 某些ID可以</li>
<li>用户密码隔离 最常使用的</li>
</ul>
<p>鉴权机制用于用户密码隔离，也是最常用的安全隔离方法</p>
<h3 id="关系型数据库和非关系型数据库"><a href="#关系型数据库和非关系型数据库" class="headerlink" title="关系型数据库和非关系型数据库"></a>关系型数据库和非关系型数据库</h3><h4 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h4><p><strong>简单来说，关系模型指的就是二维表格模型，而一个关系型数据库就是由二维表及其之间的联系所组成的一个数据组织。</strong></p>
<p><strong>关系型数据库的优点：</strong></p>
<ul>
<li>容易理解：二维表结构是非常贴近逻辑世界的一个概念，关系模型相对网状、层次等其他模型来说更容易理解</li>
<li>使用方便: 通用的SQL语言使得操作关系型数据库非常方便</li>
<li>易于维护：丰富的完整性(实体完整性、参照完整性和用户定义的完整性)大大减低了数据冗余和数据不一致的概率</li>
</ul>
<p><strong>关系型数据库瓶颈</strong></p>
<ul>
<li><p>高并发读写需求</p>
<ul>
<li>网站的用户并发性非常高，往往达到每秒上万次读写请求，对于传统关系型数据库来说，硬盘I/O是一个很大的瓶颈</li>
</ul>
</li>
<li><p>海量数据的高效率读写</p>
<ul>
<li>网站每天产生的数据量是巨大的，对于关系型数据库来说，在一张包含海量数据的表中查询，效率是非常低的</li>
</ul>
</li>
<li><p>高扩展性和可用性</p>
<ul>
<li>在基于web的结构当中，数据库是最难进行横向扩展的，当一个应用系统的用户量和访问量与日俱增的时候，数据库却没有办法像web server和app server那样简单的通过添加更多的硬件和服务节点来扩展性能和负载能力。对于很多需要提供24小时不间断服务的网站来说，对数据库系统进行升级和扩展 是非常痛苦的事情，往往需要停机维护和数据迁移。</li>
</ul>
</li>
</ul>
<h4 id="非关系型数据库"><a href="#非关系型数据库" class="headerlink" title="非关系型数据库"></a>非关系型数据库</h4><p><strong>特点</strong></p>
<ul>
<li>非结构化的存储</li>
<li>基于多维关系的模型</li>
<li>部署容易，开源免费，成本低</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li>处理高并发，大批量数据的能力强</li>
<li>支持分布式集群，负载均衡，性能高</li>
<li>内存级数据库，查询速度快</li>
<li>存储格式多</li>
<li>没有多表连接查询机制的限制，扩展性高</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>不支持SQL工业标准</li>
<li>没有JOIN等复杂的链接操作  新版已经支持</li>
<li>事务处理能力弱 新版也有了</li>
<li>没有完整性约束，对于复杂业务支持较差</li>
</ul>
<h3 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h3><h4 id="常见状态"><a href="#常见状态" class="headerlink" title="常见状态"></a>常见状态</h4><ul>
<li>1xx(临时响应)</li>
<li>2xx(成功)</li>
<li>3xx(重定向)</li>
<li>4xx(请求错误)</li>
<li>5xx(服务器错误)</li>
</ul>
<h4 id="HTTP-HTTPS的区别"><a href="#HTTP-HTTPS的区别" class="headerlink" title="HTTP || HTTPS的区别"></a>HTTP || HTTPS的区别</h4><ul>
<li>https协议需要申请证书</li>
<li>http是超文本传输协议，信息是明文传输，https则具有安全的ssl加密传输协议</li>
<li>http与https的的端口不一样前者是80 后者是443</li>
<li>加密传输比http安全</li>
</ul>
<h4 id="HTTP-1-1与1-0相比有什么差异？"><a href="#HTTP-1-1与1-0相比有什么差异？" class="headerlink" title="HTTP 1.1与1.0相比有什么差异？"></a>HTTP 1.1与1.0相比有什么差异？</h4><blockquote>
<p>HTTP 1.1于1997年1月发布，在HTTP 2.0发布前，一直被使用了15年，下面为HTTP 1.1 和1.0之间的主要差异：</p>
</blockquote>
<ul>
<li>长连接<ul>
<li>在HTTP 0.9和1.0中，TCP连线在每一次请求/回应对之后关闭。在HTTP 1.1中，引入了保持连线的机制，一个连接可以重复在多个请求/回应使用。持续连线的方式可以大大减少等待时间，因为在发出第一个请求后，双方不需要重新运行TCP握手程序。</li>
</ul>
</li>
<li>同一个Ip和端口提供不同服务<ul>
<li>能够使不同域名配置在同一个IP地址的服务器上，web server上的多个虚拟站点可以共享同一个ip和端口。</li>
</ul>
</li>
<li>带宽<ul>
<li>HTTP 1.1还使改进了HTTP 1.0的带宽。 </li>
<li>例如，HTTP 1.1引入了分块传输编码，以允许传递内容可以在持续连在线被流传输而不必使用到缓冲器。HTTP管道允许客户端在收到每个回应之前发送多个请求，进一步减少用户感受到的滞后时间。协议的另一个补充是字节服务，允许客户端请求资源的某一部分，服务器仅回应某资源的指明部分。</li>
</ul>
</li>
</ul>
<h4 id="HTTP-2-0新功能"><a href="#HTTP-2-0新功能" class="headerlink" title="HTTP 2.0新功能"></a>HTTP 2.0新功能</h4><ul>
<li>并行交错地发送多个请求，请求之间互不影响。</li>
<li>并行交错地发送多个响应，响应之间互不干扰。</li>
<li>使用一个连接并行发送多个请求和响应。</li>
<li>所有通信都在一个 TCP 连接上完成，此连接可以承载任意数量的双向数据流。</li>
</ul>
<h3 id="async与await原理"><a href="#async与await原理" class="headerlink" title="async与await原理"></a>async与await原理</h3><h3 id="KOA"><a href="#KOA" class="headerlink" title="KOA"></a>KOA</h3><h3 id="Promise的实现原理"><a href="#Promise的实现原理" class="headerlink" title="Promise的实现原理"></a>Promise的实现原理</h3><h3 id="如果避免高并发"><a href="#如果避免高并发" class="headerlink" title="如果避免高并发"></a>如果避免高并发</h3><ul>
<li>优化数据库</li>
<li>加索引</li>
</ul>
<h3 id="SQL语法"><a href="#SQL语法" class="headerlink" title="SQL语法"></a>SQL语法</h3><p>select from where  //条件查询</p>
<pre><code>`SELECT * FROM Persons WHERE City=&apos;Beijing&apos;`</code></pre><p>order by  排序</p>
<p>limit  返回数量</p>
<ul>
<li><p>like</p>
<ul>
<li>SQL LIKE子句中使用 %  字符来表示任意字符，包含某个字段中含有 “XXX”记录的值</li>
<li><code>SELECT * FROM &lt;表名&gt; WHERE &lt;name&gt; LIKE &quot;字段中包含的&quot;</code></li>
</ul>
</li>
<li><p>in </p>
<ul>
<li>IN 操作符允许我们在 WHERE 子句中规定多个值。</li>
<li><code>SELECT * FROM Persons WHERE lastName IN(&#39;aDMIN&#39;,&#39;caret&#39;)</code></li>
</ul>
</li>
<li><p>between  </p>
<ul>
<li>BETWEEN 操作符在WHERE子句中 使用，作用是选取介于两个值之前的数据范围</li>
<li>如需以字母顺序显示介于 “Adams”（包括）和 “Carter”（不包括）之间的人，请使用下面的 SQL：</li>
<li><code>SELECT * FROM Persons WHERE lastName BETWEEN &#39;Adams&#39; AND &#39;Carter&#39;</code></li>
</ul>
</li>
<li><p>join // inner join, left join, right join</p>
<ul>
<li>SQL join 用于根据两个或多个表中的列之间的关系，从这些表中查询数据。<br>group by</li>
<li><code>SELECT Persons.LastNmae,Persons.FirstName,Order.OrderNo FROM Persons INNER JOIN Orders ON Persons.id_p = Orders.id_P ORDER BY Persons.LastNmae</code></li>
</ul>
</li>
<li><p>count</p>
<ul>
<li>COUNT(column_name) 函数返回指定列的值的数目</li>
<li><code>SELECT COUNT(*) AS NumberOFOrders FROM Orders</code></li>
</ul>
</li>
<li><p>avg</p>
<ul>
<li>AVG 函数返回数值列的平均值。NULL 值不包括在计算中。</li>
<li><code>SELECT AVG(OrderPrice) AS orderLenght FROM Orders</code></li>
</ul>
</li>
<li><p>sum</p>
<ul>
<li>SUM 函数返回数值列的总数（总额）。</li>
<li><code>SELECT COUNT(OrderPrice) AS OrderTotal FROM order</code></li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://lizheguang.github.io/2018/12/17/node%E9%9D%A2%E8%AF%95/" data-id="ckcjwflvh000c0f976eaafkax" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-云开发初探" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/27/%E4%BA%91%E5%BC%80%E5%8F%91%E5%88%9D%E6%8E%A2/" class="article-date">
  <time datetime="2018-09-27T10:29:05.000Z" itemprop="datePublished">2018-09-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/27/%E4%BA%91%E5%BC%80%E5%8F%91%E5%88%9D%E6%8E%A2/">云开发初探</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="小程序编辑器生成云开发探索"><a href="#小程序编辑器生成云开发探索" class="headerlink" title="小程序编辑器生成云开发探索"></a>小程序编辑器生成云开发探索</h1><blockquote>
<p>本文档建立于编辑器生成的云开发为基础进行阅读</p>
</blockquote>
<!-- TOC -->

<ul>
<li><a href="#小程序编辑器生成云开发探索">小程序编辑器生成云开发探索</a><ul>
<li><a href="#wxcloundcallfunction">wx.clound.callFunction</a><ul>
<li><a href="#云函数">云函数</a></li>
</ul>
</li>
<li><a href="#常用的方法增删改查">常用的方法(增删改查)</a><ul>
<li><a href="#增加数据">增加数据</a></li>
<li><a href="#删除数据">删除数据</a></li>
<li><a href="#更新数据">更新数据</a></li>
<li><a href="#查询数据">查询数据</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- /TOC -->

<h2 id="wx-clound-callFunction"><a href="#wx-clound-callFunction" class="headerlink" title="wx.clound.callFunction"></a>wx.clound.callFunction</h2><p><strong>调用云函数</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">wx.cloud.callFunction(&#123;</span><br><span class="line">     name: &#39;login&#39;,</span><br><span class="line">     data: &#123;&#125;,</span><br><span class="line">     success: res &#x3D;&gt; &#123;</span><br><span class="line">       console.log(&#39;[云函数] [login] user openid: &#39;, res.result.openid)</span><br><span class="line">       app.globalData.openid &#x3D; res.result.openid</span><br><span class="line">       wx.navigateTo(&#123;</span><br><span class="line">         url: &#39;..&#x2F;userConsole&#x2F;userConsole&#39;,</span><br><span class="line">       &#125;)</span><br><span class="line">     &#125;,</span><br><span class="line">     fail: err &#x3D;&gt; &#123;</span><br><span class="line">       console.error(&#39;[云函数] [login] 调用失败&#39;, err)</span><br><span class="line">       wx.navigateTo(&#123;</span><br><span class="line">         url: &#39;..&#x2F;deployFunctions&#x2F;deployFunctions&#39;,</span><br><span class="line">       &#125;)</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure>
<h3 id="云函数"><a href="#云函数" class="headerlink" title="云函数"></a>云函数</h3><p>函数是一段运行在云端的代码，无需管理服务器，在开发工具内编写、一键上传部署即可运行后端代码。</p>
<p>小程序内提供了专门用于云函数调用的 API。开发者可以在云函数内获取到每次调用的上下文（appid、openid 等），无需维护复杂的鉴权机制，即可获取天然可信任的用户登录态（openid）。</p>
<p>比如我们如下定义一个云函数，命名为 add ，功能是将传入的两个参数 a 和 b 相加：</p>
<p><strong>// index.js 是入口文件，云函数被调用时会执行该文件导出的 main 方法<br>// event 包含了调用端（小程序端）调用该函数时传过来的参数，同时还包含了用户登录态 <code>openId</code> 和小程序 <code>appId</code> 信息</strong></p>
<p><strong>云函数会默认的把用户的openID与小程序id传入到参数里</strong></p>
<p><a href="https://developers.weixin.qq.com/miniprogram/dev/wxcloud/basis/capabilities.html#%E4%BA%91%E5%87%BD%E6%95%B0" target="_blank" rel="noopener">扩展阅读</a></p>
<h2 id="常用的方法-增删改查"><a href="#常用的方法-增删改查" class="headerlink" title="常用的方法(增删改查)"></a>常用的方法(增删改查)</h2><h3 id="增加数据"><a href="#增加数据" class="headerlink" title="增加数据"></a>增加数据</h3><p><strong>Collection.add</strong></p>
<p>在集合上新增记录</p>
<p>官方案列：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">db.collection(&#39;todos&#39;).add(&#123;</span><br><span class="line">  &#x2F;&#x2F; data 字段表示需新增的 JSON 数据</span><br><span class="line">  data: &#123;</span><br><span class="line">    &#x2F;&#x2F; _id: &#39;todo-identifiant-aleatoire&#39;, &#x2F;&#x2F; 可选自定义 _id，在此处场景下用数据库自动分配的就可以了</span><br><span class="line">    description: &quot;learn cloud database&quot;,</span><br><span class="line">    due: new Date(&quot;2018-09-01&quot;),</span><br><span class="line">    tags: [</span><br><span class="line">      &quot;cloud&quot;,</span><br><span class="line">      &quot;database&quot;</span><br><span class="line">    ],</span><br><span class="line">    &#x2F;&#x2F; 为待办事项添加一个地理位置（113°E，23°N）</span><br><span class="line">    location: new db.Geo.Point(113, 23),</span><br><span class="line">    done: false</span><br><span class="line">  &#125;,</span><br><span class="line">  success: function(res) &#123;</span><br><span class="line">    &#x2F;&#x2F; res 是一个对象，其中有 _id 字段标记刚创建的记录的 id</span><br><span class="line">    console.log(res)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><a href="https://developers.weixin.qq.com/miniprogram/dev/wxcloud/guide/database/add.html" target="_blank" rel="noopener">扩展阅读</a></p>
<h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><p><strong>Document.remove</strong></p>
<p>示例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.collection(&#39;todos&#39;).doc(&#39;todo-identifiant-aleatoire&#39;).remove(&#123;</span><br><span class="line">  success: console.log,</span><br><span class="line">  fail: console.error</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>实战案例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">onRemove: function() &#123;</span><br><span class="line">  if (this.data.counterId) &#123;</span><br><span class="line">    const db &#x3D; wx.cloud.database()</span><br><span class="line">    db.collection(&#39;counters&#39;).doc(this.data.counterId).remove(&#123;</span><br><span class="line">      success: res &#x3D;&gt; &#123;</span><br><span class="line">        wx.showToast(&#123;</span><br><span class="line">          title: &#39;删除成功&#39;,</span><br><span class="line">        &#125;)</span><br><span class="line">        this.setData(&#123;</span><br><span class="line">          counterId: &#39;&#39;,</span><br><span class="line">          count: null,</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;,</span><br><span class="line">      fail: err &#x3D;&gt; &#123;</span><br><span class="line">        wx.showToast(&#123;</span><br><span class="line">          icon: &#39;none&#39;,</span><br><span class="line">          title: &#39;删除失败&#39;,</span><br><span class="line">        &#125;)</span><br><span class="line">        console.error(&#39;[数据库] [删除记录] 失败：&#39;, err)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    wx.showToast(&#123;</span><br><span class="line">      title: &#39;无记录可删，请见创建一个记录&#39;,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p><a href="https://developers.weixin.qq.com/miniprogram/dev/wxcloud/reference-client-api/database/doc.remove.html" target="_blank" rel="noopener">扩展阅读</a></p>
<h3 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h3><p><strong>Document.update</strong></p>
<p>options 为必填参数，是一个如下格式的对象，如传入 success、fail、complete 三者之一，则表示使用回调风格，不返回 Promise。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">db.collection(&#39;todos&#39;).doc(&#39;todo-identifiant-aleatoire&#39;).update(&#123;</span><br><span class="line">  &#x2F;&#x2F; data 传入需要局部更新的数据</span><br><span class="line">  data: &#123;</span><br><span class="line">    &#x2F;&#x2F; 表示将 done 字段置为 true</span><br><span class="line">    done: true</span><br><span class="line">  &#125;,</span><br><span class="line">  success: console.log,</span><br><span class="line">  fail: console.error</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>案列：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">onCounterDec: function() &#123;</span><br><span class="line">    const db &#x3D; wx.cloud.database()</span><br><span class="line">    const newCount &#x3D; this.data.count - 1</span><br><span class="line">    db.collection(&#39;counters&#39;).doc(this.data.counterId).update(&#123;</span><br><span class="line">      data: &#123;</span><br><span class="line">        count: newCount</span><br><span class="line">      &#125;,</span><br><span class="line">      success: res &#x3D;&gt; &#123;</span><br><span class="line">        this.setData(&#123;</span><br><span class="line">          count: newCount</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;,</span><br><span class="line">      fail: err &#x3D;&gt; &#123;</span><br><span class="line">        icon: &#39;none&#39;,</span><br><span class="line">        console.error(&#39;[数据库] [更新记录] 失败：&#39;, err)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
<p><a href="https://developers.weixin.qq.com/miniprogram/dev/wxcloud/reference-client-api/database/doc.update.html" target="_blank" rel="noopener">扩展阅读</a></p>
<h3 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h3><p><strong>Collection.get / Query.get</strong></p>
<p>获取集合数据，或获取根据查询条件筛选后的集合数据。</p>
<p>如果没有指定 limit，则默认最多取 20 条记录。</p>
<p>如果没有指定 skip，则默认从第 0 条记录开始取，skip 常用于分页</p>
<p><a href="https://developers.weixin.qq.com/miniprogram/dev/wxcloud/guide/database/read.html" target="_blank" rel="noopener">扩展阅读</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://lizheguang.github.io/2018/09/27/%E4%BA%91%E5%BC%80%E5%8F%91%E5%88%9D%E6%8E%A2/" data-id="ckcjwflv900040f978s1s2bl8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-生成hexo目录的工具-koa-generator" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/26/%E7%94%9F%E6%88%90hexo%E7%9B%AE%E5%BD%95%E7%9A%84%E5%B7%A5%E5%85%B7-koa-generator/" class="article-date">
  <time datetime="2018-09-26T05:51:02.000Z" itemprop="datePublished">2018-09-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/26/%E7%94%9F%E6%88%90hexo%E7%9B%AE%E5%BD%95%E7%9A%84%E5%B7%A5%E5%85%B7-koa-generator/">生成hexo目录的工具 koa-generator</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>###Features</p>
<p>Express-style<br>Support koa 1.x（supported）<br>Support koa 2.x（koa middleware supported,need Node.js 7.6+ ,babel optional）</p>
<p>Installation<br>$ npm install -g koa-generator<br>with 2 commands</p>
<p>koa (Support koa 1.x)<br>koa2 (Support koa 2.x)<br>Quick Start 1.x<br>The quickest way to get started with koa is to utilize the executable koa(1) to generate an application as shown below:</p>
<p>Create the app:</p>
<p>$ koa /tmp/foo &amp;&amp; cd /tmp/foo<br>Install dependencies:</p>
<p>$ npm install<br>Rock and Roll</p>
<p>$ npm start<br>Quick Start 2.x<br>The quickest way to get started with koa is to utilize the executable koa2(1) to generate an application as shown below:</p>
<p>Create the app:</p>
<p>$ koa2 /tmp/foo &amp;&amp; cd /tmp/foo<br>Install dependencies:</p>
<p>$ npm install<br>Rock and Roll</p>
<p>$ npm start<br>more detail see koa2-demo</p>
<p>Command Line Options<br>This generator can also be further configured with the following command line flags.</p>
<p>-h, –help          output usage information<br>-V, –version       output the version number<br>-e, –ejs           add ejs engine support (defaults to jade)<br>    –hbs           add handlebars engine support<br>-n, –nunjucks      add nunjucks engine support<br>-H, –hogan         add hogan.js engine support<br>-c, –css <engine>  add stylesheet <engine> support (less|stylus|compass|sass) (defaults to plain css)<br>    –git           add .gitignore<br>-f, –force         force on non-empty directory<br>目前选项-c还没有实现</p>
<p>Git Branch Details<br>master = koa generator<br>tpl = koa 1.x template<br>tpl_2.x = koa 2.x template<br>License</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://lizheguang.github.io/2018/09/26/%E7%94%9F%E6%88%90hexo%E7%9B%AE%E5%BD%95%E7%9A%84%E5%B7%A5%E5%85%B7-koa-generator/" data-id="ckcjwflvg00090f976qrf2u37" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-mongoose文档翻译" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/25/mongoose%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91/" class="article-date">
  <time datetime="2018-09-25T10:28:45.000Z" itemprop="datePublished">2018-09-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/25/mongoose%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91/">mongoose文档翻译</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="mongoose-文档翻译"><a href="#mongoose-文档翻译" class="headerlink" title="mongoose 文档翻译"></a>mongoose 文档翻译</h1><p>[TOC]</p>
<h3 id="Getting-Started（入门）"><a href="#Getting-Started（入门）" class="headerlink" title="Getting Started（入门）"></a>Getting Started（入门）</h3><p>First be sure you have MongoDB and Node.js installed.</p>
<p>Next install Mongoose from the command line using npm:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install mongoose</span><br></pre></td></tr></table></figure>

<p>现在说我们喜欢的小猫，想要记录我们在MongoDB中见过的每只小猫。我们需要做的第一件事是在项目中包含mongoose，并在我们本地运行的MongoDB实例上打开与测试数据库的连接。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; getting-started.js</span><br><span class="line">var mongoose &#x3D; require(&#39;mongoose&#39;);</span><br><span class="line">mongoose.connect(&#39;mongodb:&#x2F;&#x2F;localhost&#x2F;test&#39;);</span><br></pre></td></tr></table></figure>
<p>我们与在localhost上运行的测试数据库有挂起的连接。如果我们成功连接或发生连接错误，我们现在需要收到通知：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var db &#x3D; mongoose.connection;</span><br><span class="line">db.on(&#39;error&#39;, console.error.bind(console, &#39;connection error:&#39;));</span><br><span class="line">db.once(&#39;open&#39;, function() &#123;</span><br><span class="line">  &#x2F;&#x2F; we&#39;re connected!</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>一旦我们的连接打开，我们的回调就会被调用。为简洁起见，我们假设所有以下代码都在此回调中。</p>
<p>使用Mongoose，一切都来自Schema。让我们来参考它并定义我们的小猫。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var kittySchema &#x3D; new mongoose.Schema(&#123;</span><br><span class="line">  name: String</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>到现在为止还挺好。我们有一个带有一个属性name的模式，它将是一个String。下一步是将模式编译为模型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var Kitten &#x3D; mongoose.model(&#39;Kitten&#39;, kittySchema);</span><br></pre></td></tr></table></figure>
<p>模型是用于构造文档的类。在这种情况下，每个文档都将是一个小猫，其属性和行为在我们的模式中声明。让我们创建一个小猫文件，代表我们刚刚在人行道上遇到的小家伙：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var silence &#x3D; new Kitten(&#123; name: &#39;Silence&#39; &#125;);</span><br><span class="line">console.log(silence.name); &#x2F;&#x2F; &#39;Silence&#39;</span><br></pre></td></tr></table></figure>

<p>小猫可以喵喵叫，让我们来看看如何在我们的文档中添加“说话”功能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; NOTE: methods must be added to the schema before compiling it with mongoose.model()</span><br><span class="line">&#x2F;&#x2F;注意：在使用mongoose.model（）编译方法之前，必须将方法添加到模式中</span><br><span class="line">kittySchema.methods.speak &#x3D; function () &#123;</span><br><span class="line">  var greeting &#x3D; this.name</span><br><span class="line">    ? &quot;Meow name is &quot; + this.name</span><br><span class="line">    : &quot;I don&#39;t have a name&quot;;</span><br><span class="line">  console.log(greeting);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var Kitten &#x3D; mongoose.model(&#39;Kitten&#39;, kittySchema);</span><br></pre></td></tr></table></figure>

<p>添加到模式的methods属性的函数将编译到Model原型中并在每个文档实例上公开：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var fluffy &#x3D; new Kitten(&#123; name: &#39;fluffy&#39; &#125;);</span><br><span class="line">fluffy.speak(); &#x2F;&#x2F; &quot;Meow name is fluffy&quot;</span><br></pre></td></tr></table></figure>
<p>我们有说话的小猫！但是我们还没有向MongoDB保存任何内容。可以通过调用其save方法将每个文档保存到数据库中。如果发生任何回调，回调的第一个参数将是错误。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fluffy.save(function (err, fluffy) &#123;</span><br><span class="line">    if (err) return console.error(err);</span><br><span class="line">    fluffy.speak();</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p>我们想要显示我们见过的所有小猫,我们可以通过我们的Kitten模型访问所有小猫文档。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Kitten.find(function (err, kittens) &#123;</span><br><span class="line">  if (err) return console.error(err);</span><br><span class="line">  console.log(kittens);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>我们刚刚将数据库中的所有小猫记录到控制台。如果我们想按名称过滤我们的小猫，Mongoose支持MongoDB丰富的查询语法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Kitten.find(&#123; name: &#x2F;^fluff&#x2F; &#125;, callback);</span><br></pre></td></tr></table></figure>

<p>这将搜索具有以“Fluff”开头的name属性的所有文档，并将结果作为小猫数组返回给回调。祝贺这是我们快速启动的结束。我们使用Mongoose在MongoDB中创建了一个模式，添加了一个自定义文档方法，保存和查询的小猫。转到指南或API文档了解更多信息。</p>
<h3 id="Guides-指南"><a href="#Guides-指南" class="headerlink" title="Guides 指南"></a>Guides 指南</h3><p>Mongoose指南提供有关Mongoose核心概念的详细教程，并将Mongoose与外部工具和框架集成在一起。</p>
<h4 id="Schemas"><a href="#Schemas" class="headerlink" title="Schemas"></a>Schemas</h4><p>如果您还没有这样做，请花一点时间阅读快速入门，了解Mongoose的工作原理。如果您要从4.x迁移到5.x，请花点时间阅读迁移指南。</p>
<p><strong>Defining your schema （定义架构）</strong>  </p>
<p>Everything in Mongoose starts with a Schema. Each schema maps to a MongoDB collection and defines the shape of the documents within that collection.</p>
<p>Mongoose中的所有内容都以Schema开头。每个模式都映射到MongoDB集合，并定义该集合中文档的形状。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var mongoose &#x3D; require(&#39;mongoose&#39;);</span><br><span class="line">  var Schema &#x3D; mongoose.Schema;</span><br><span class="line"></span><br><span class="line">  var blogSchema &#x3D; new Schema(&#123;</span><br><span class="line">    title:  String,</span><br><span class="line">    author: String,</span><br><span class="line">    body:   String,</span><br><span class="line">    comments: [&#123; body: String, date: Date &#125;],</span><br><span class="line">    date: &#123; type: Date, default: Date.now &#125;,</span><br><span class="line">    hidden: Boolean,</span><br><span class="line">    meta: &#123;</span><br><span class="line">      votes: Number,</span><br><span class="line">      favs:  Number</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>允许的SchemaTypes是：</p>
<ul>
<li>String</li>
<li>Number</li>
<li>Date</li>
<li>Buffer</li>
<li>Boolean</li>
<li>Mixed</li>
<li>ObjectId</li>
<li>Array</li>
<li>Decimal128</li>
<li>Map</li>
</ul>
<p><a href="https://mongoosejs.com/docs/schematypes.html#schematypes" target="_blank" rel="noopener"><strong>SchemaTypes 的更多信息</strong></a></p>
<p>模式不仅定义了文档的结构和属性的转换，还定义了文档实例方法，静态模型方法，复合索引和称为中间件的文档生命周期钩子。</p>
<p>Creating a model 创建模型</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://lizheguang.github.io/2018/09/25/mongoose%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91/" data-id="ckcjwflva00050f97c95o2282" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mongoose-%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91/" rel="tag">mongoose 文档翻译</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-小程序开发之利用本地缓存提前渲染界面" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/25/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E4%B9%8B%E5%88%A9%E7%94%A8%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98%E6%8F%90%E5%89%8D%E6%B8%B2%E6%9F%93%E7%95%8C%E9%9D%A2/" class="article-date">
  <time datetime="2018-09-25T10:02:14.000Z" itemprop="datePublished">2018-09-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/25/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E4%B9%8B%E5%88%A9%E7%94%A8%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98%E6%8F%90%E5%89%8D%E6%B8%B2%E6%9F%93%E7%95%8C%E9%9D%A2/">小程序开发之利用本地缓存提前渲染界面</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="小程序开发之利用本地缓存提前渲染界面"><a href="#小程序开发之利用本地缓存提前渲染界面" class="headerlink" title="小程序开发之利用本地缓存提前渲染界面"></a>小程序开发之利用本地缓存提前渲染界面</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">“摘自微信官方团队”</span><br><span class="line">讨论一个需求：我们要实现了一个购物商城的小程序，首页是展示一堆商品的列表。一般的实现方法就是在页面onLoad回调之后通过wx.request向服务器发起一个请求去拉取首页的商品列表数据，等待wx.request的success回调之后把数据通过setData渲染到界面上。</span><br></pre></td></tr></table></figure>

<p>那么，在这种正常的请求中，是否还能有优化的方法？</p>
<p>以下代码为微信团队提供的优化思路</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">  onLoad: function() &#123;</span><br><span class="line">    var that &#x3D; this</span><br><span class="line">    var list &#x3D;wx.getStorageSync(&quot;list&quot;)</span><br><span class="line">    if (list) &#123; &#x2F;&#x2F; 本地如果有缓存列表，提前渲染</span><br><span class="line">      that.setData(&#123;</span><br><span class="line">        list: list</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    wx.request(&#123;</span><br><span class="line">      url: &#39;https:&#x2F;&#x2F;test.com&#x2F;getproductlist&#39;,</span><br><span class="line">      success: function (res) &#123;</span><br><span class="line">        if (res.statusCode &#x3D;&#x3D;&#x3D; 200) &#123;</span><br><span class="line">          list &#x3D; res.data.list</span><br><span class="line">          that.setData(&#123; &#x2F;&#x2F; 再次渲染列表</span><br><span class="line">            list: list</span><br><span class="line">          &#125;)</span><br><span class="line">          wx.setStorageSync(&quot;list&quot;,list) &#x2F;&#x2F; 覆盖缓存数据</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>


<hr>
<p><strong>解析简单以上简单的代码</strong>：</p>
<p>这种做法可以让用户体验你的小程序时感觉加载非常快，但是你还要留意这个做法的缺点，如果小程序对渲染的数据实时性要求非常高的话，用户看到一个旧数据的界面会非常困惑。因此一般在对数据实时性/一致性要求不高的页面采用这个方法来做提前渲染，用以优化小程序体验。</p>
<p>整理这段官方的说明:</p>
<p><strong>优点</strong><br>让用户感知到小程序加载的速度非常快！</p>
<p><strong>为什么？</strong><br>假设发送请求之后的2秒内收到返回，那么在请求返回前可以渲染本地缓存的数据，不会产生用户，盯着一个白页面与加载页的情况。<br>避免了普遍的没有数据会留白与加载中的场景</p>
<p><strong>原因：</strong><br>在发起请求之前就可以把缓存进行渲染，在请求成功之后再次进行请求后返回的数据渲染。</p>
<p><strong>缺点</strong><br>难免会有老数据的一闪而过，如果请求服务端过程中不给力的话，会让用户在很长时间看到不正确的数据！</p>
<p><strong>使用场景</strong><br>数据不会实时变更的场景<br>用户认为这个不是很重要的场景<br>有本地缓存与无本地缓存的对比<br>对比条件为 “用户看到页面数据展现的时间”<br>测试场景为小程序模拟器</p>
<p>以上截图仅为，在模拟器上运行，无缓存总会比有缓存的提前平均在300MS的时间让用户感观到视图，当然模拟器上会有瑕疵的白色页面。</p>
<p>怎么样更好的使用微信小程序缓存？</p>
<p><strong>什么时候使用本地缓存？</strong><br>不能乱用</p>
<p>举个列子：订单列表，退换货商品详情这些地方不能用，如果一个商品的价格随意变动，只会给用户带来不稳定的因素。</p>
<p>什么时候要删除本地缓存？（这个我感觉还好）</p>
<p>小程序有10MB缓存大小，如果本地缓存超过10M，添加本地缓存的时候就会fail</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://lizheguang.github.io/2018/09/25/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E4%B9%8B%E5%88%A9%E7%94%A8%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98%E6%8F%90%E5%89%8D%E6%B8%B2%E6%9F%93%E7%95%8C%E9%9D%A2/" data-id="ckcjwflvb00060f97734b8r22" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-webpack-官方文档" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/13/webpack-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/" class="article-date">
  <time datetime="2018-07-13T10:54:44.000Z" itemprop="datePublished">2018-07-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/13/webpack-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/">webpack-官方文档</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h4><p>###clean-webpack-plugin</p>
<p>你可能已经注意到，由于过去的指南和代码示例遗留下来，导致我们的 /dist 文件夹相当杂乱。webpack 会生成文件，然后将这些文件放置在 /dist 文件夹中，但是 webpack 无法追踪到哪些文件是实际在项目中用到的。</p>
<p>通常，在每次构建前清理 /dist 文件夹，是比较推荐的做法，因此只会生成用到的文件。让我们完成这个需求。</p>
<p>clean-webpack-plugin 是一个比较普及的管理插件，让我们安装和配置下。</p>
<hr>
<p><img src="./1531383837459.png" alt="Alt text"></p>
<hr>
<p>###使用 source map</p>
<p>当 webpack 打包源代码时，可能会很难追踪到错误和警告在源代码中的原始位置。例如，如果将三个源文件（a.js, b.js 和 c.js）打包到一个 bundle（bundle.js）中，而其中一个源文件包含一个错误，那么堆栈跟踪就会简单地指向到 bundle.js。这并通常没有太多帮助，因为你可能需要准确地知道错误来自于哪个源文件。</p>
<p>为了更容易地追踪错误和警告，JavaScript 提供了 source map 功能，将编译后的代码映射回原始源代码。如果一个错误来自于 b.js，source map 就会明确的告诉你。</p>
<p>source map 有很多不同的选项可用，请务必仔细阅读它们，以便可以根据需要进行配置。</p>
<p>对于本指南，我们使用 inline-source-map 选项，这有助于解释说明我们的目的</p>
<hr>
<p>###模块热替换<br>模块热替换(Hot Module Replacement 或 HMR)是 webpack 提供的最有用的功能之一。它允许在运行时更新各种模块，而无需进行完全刷新。</p>
<p><strong>问题</strong></p>
<p>模块热替换可能比较难掌握。为了说明这一点，我们回到刚才的示例中。如果你继续点击示例页面上的按钮，你会发现控制台仍在打印这旧的 printMe 功能。</p>
<p>这是因为按钮的 onclick 事件仍然绑定在旧的 printMe 函数上。</p>
<p>为了让它与 HRM 正常工作，我们需要使用 module.hot.accept 更新绑定到新的 printMe 函数上：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> import _ from &#39;lodash&#39;;</span><br><span class="line"> import printMe from &#39;.&#x2F;print.js&#39;;</span><br><span class="line"></span><br><span class="line"> function component() &#123;</span><br><span class="line">   var element &#x3D; document.createElement(&#39;div&#39;);</span><br><span class="line">   var btn &#x3D; document.createElement(&#39;button&#39;);</span><br><span class="line"></span><br><span class="line">   element.innerHTML &#x3D; _.join([&#39;Hello&#39;, &#39;webpack&#39;], &#39; &#39;);</span><br><span class="line"></span><br><span class="line">   btn.innerHTML &#x3D; &#39;Click me and check the console!&#39;;</span><br><span class="line">   btn.onclick &#x3D; printMe;  &#x2F;&#x2F; onclick 事件绑定原始的 printMe 函数上</span><br><span class="line"></span><br><span class="line">   element.appendChild(btn);</span><br><span class="line"></span><br><span class="line">   return element;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">let element &#x3D; component(); &#x2F;&#x2F; 当 print.js 改变导致页面重新渲染时，重新获取渲染的元素</span><br><span class="line">document.body.appendChild(element);</span><br><span class="line"></span><br><span class="line"> if (module.hot) &#123;</span><br><span class="line">   module.hot.accept(&#39;.&#x2F;print.js&#39;, function() &#123;</span><br><span class="line">     console.log(&#39;Accepting the updated printMe module!&#39;);</span><br><span class="line">    document.body.removeChild(element);</span><br><span class="line">    element &#x3D; component(); &#x2F;&#x2F; 重新渲染页面后，component 更新 click 事件处理</span><br><span class="line">    document.body.appendChild(element);</span><br><span class="line">   &#125;)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h5 id="HMR-修改样式表"><a href="#HMR-修改样式表" class="headerlink" title="HMR 修改样式表"></a>HMR 修改样式表</h5><p>借助于 style-loader 的帮助，CSS 的模块热替换实际上是相当简单的。当更新 CSS 依赖模块时，此 loader 在后台使用 module.hot.accept 来修补(patch)  标签。</p>
<p>所以，可以使用以下命令安装两个 loader ：</p>
<p><code>npm install --save-dev style-loader css-loader</code></p>
<p><img src="./1531394549181.png" alt="Alt text"></p>
<hr>
<h3 id="tree-shaking"><a href="#tree-shaking" class="headerlink" title="tree shaking"></a>tree shaking</h3><p>ree shaking 是一个术语，通常用于描述移除 JavaScript 上下文中的未引用代码(dead-code)。它依赖于 ES2015 模块系统中的静态结构特性，例如 import 和 export。这个术语和概念实际上是兴起于 ES2015 模块打包工具 rollup。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">webpack.config.js</span><br><span class="line"></span><br><span class="line">mode:&quot;development&quot; &#x2F;&#x2F;development不压缩  &#x2F;&#x2F;production压缩</span><br></pre></td></tr></table></figure>


<hr>
<h3 id="生产环境构建"><a href="#生产环境构建" class="headerlink" title="生产环境构建"></a>生产环境构建</h3><p>在本指南中，我们将深入一些最佳实践，并且使用工具，将网站或应用程序构建到生产环境中。</p>
<hr>
<h3 id="代码分离"><a href="#代码分离" class="headerlink" title="代码分离"></a>代码分离</h3><p>代码分离是 webpack 中最引人注目的特性之一。此特性能够把代码分离到不同的 bundle 中，然后可以按需加载或并行加载这些文件。代码分离可以用于获取更小的 bundle，以及控制资源加载优先级，如果使用合理，会极大影响加载时间。</p>
<h4 id="入口起点-entry-points"><a href="#入口起点-entry-points" class="headerlink" title="入口起点(entry points)"></a>入口起点(entry points)</h4><p>这是迄今为止最简单、最直观的分离代码的方式。不过，这种方式手动配置较多，并有一些陷阱，我们将会解决这些问题。先来看看如何从 main bundle 中分离另一个模块：</p>
<hr>
<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h3 id="Heading"><a href="#Heading" class="headerlink" title="Heading"></a>Heading</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://lizheguang.github.io/2018/07/13/webpack-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/" data-id="ckcjwflv700020f97e9eqguhe" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-掘金-webapck" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/13/%E6%8E%98%E9%87%91-webapck/" class="article-date">
  <time datetime="2018-07-13T10:52:42.000Z" itemprop="datePublished">2018-07-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/13/%E6%8E%98%E9%87%91-webapck/">掘金-webapck</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="掘金webpack小册"><a href="#掘金webpack小册" class="headerlink" title="掘金webpack小册"></a>掘金webpack小册</h1><h2 id="webpack-的概念和基础使用"><a href="#webpack-的概念和基础使用" class="headerlink" title="webpack 的概念和基础使用"></a>webpack 的概念和基础使用</h2><p>我们在小册介绍中提到，webpack 是一个 JS 代码模块化的打包工具，藉由它强大的扩展能力，随着社区的发展，逐渐成为一个功能完善的构建工具。相信开始学习这个小册的同学们多多少少都能够理解为什么前端开发中会使用到 webpack，我们不再详细介绍 webpack 的使用背景，直奔本小节的主题。…</p>
<p>因为是作为项目依赖进行安装，所以不会有全局的命令，npm/yarn 会帮助我们在当前项目依赖中寻找对应的命令执行，如果是全局安装的 webpack，直接执行 webpack –mode production 就可以。</p>
<p>webpack 4.x 的版本可以零配置就开始进行构建，但是笔者觉得这个功能还不全面，缺少很多实际项目需要的功能，所以基本你还是需要一个配置文件，后边会详细讲解。</p>
<p>我们先来了解 webpack 中的一些基本概念。…</p>
<hr>
<h3 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h3><p>webpack 中提供一种处理多种文件格式的机制，便是使用 loader。我们可以把 loader 理解为是一个转换器，负责把某种文件格式的内容转换成 webpack 可以支持打包的模块。</p>
<p>举个例子，在没有添加额外插件的情况下，webpack 会默认把所有依赖打包成 js 文件，如果入口文件依赖一个 .hbs 的模板文件以及一个 .css 的样式文件，那么我们需要 handlebars-loader 来处理 .hbs 文件，需要 css-loader 来处理 .css 文件（这里其实还需要 style-loader，后续详解），最终把不同格式的文件都解析成 js 代码，以便打包后在浏览器中运行。</p>
<p>当我们需要使用不同的 loader 来解析处理不同类型的文件时，我们可以在 module.rules 字段下来配置相关的规则，例如使用 Babel 来处理 .js 文件：…</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: &#x2F;\.jsx?&#x2F;, &#x2F;&#x2F; 匹配文件路径的正则表达式，通常我们都是匹配文件类型后缀</span><br><span class="line">      include: [</span><br><span class="line">        path.resolve(__dirname, &#39;src&#39;) &#x2F;&#x2F; 指定哪些路径下的文件需要经过 loader 处理</span><br><span class="line">      ],</span><br><span class="line">      use: &#39;babel-loader&#39;, &#x2F;&#x2F; 指定使用的 loader</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;...</span><br></pre></td></tr></table></figure>


<hr>
<h3 id="plugin"><a href="#plugin" class="headerlink" title="plugin"></a>plugin</h3><p>在 webpack 的构建流程中，plugin 用于处理更多其他的一些构建任务。可以这么理解，模块代码转换的工作由 loader 来处理，除此之外的其他任何工作都可以交由 plugin 来完成。通过添加我们需要的 plugin，可以满足更多构建中特殊的需求。例如，要使用压缩 JS 代码的 uglifyjs-webpack-plugin 插件，只需在配置中通过 plugins 字段添加新的 plugin 即可：…</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const UglifyPlugin &#x3D; require(&#39;uglifyjs-webpack-plugin&#39;)</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    new UglifyPlugin()</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<hr>
<h2 id="搭建基本的前端开发环境"><a href="#搭建基本的前端开发环境" class="headerlink" title="搭建基本的前端开发环境"></a>搭建基本的前端开发环境</h2><p>我们日常使用的前端开发环境应该是怎样的？我们可以尝试着把基本前端开发环境的需求列一下：</p>
<p>构建我们发布需要的 HTML、CSS、JS 文件<br>使用 CSS 预处理器来编写样式<br>处理和压缩图片<br>使用 Babel 来支持 ES 新特性<br>本地提供静态服务以方便开发调试…</p>
<h3 id="html-webpack-plugin-什么时候使用？"><a href="#html-webpack-plugin-什么时候使用？" class="headerlink" title="html-webpack-plugin 什么时候使用？"></a><strong>html-webpack-plugin</strong> 什么时候使用？</h3><p>如果我们的文件名或者路径会变化，例如使用 [hash] 来进行命名，那么最好是将 HTML 引用路径和我们的构建结果关联起来，这个时候我们可以使用</p>
<hr>
<h2 id="使用Plugin"><a href="#使用Plugin" class="headerlink" title="使用Plugin"></a>使用Plugin</h2><p>webpack 中的 plugin 大多都提供额外的能力，它们在 webpack 中的配置都只是把插件实例添加到 plugins 字段的数组中。不过由于需要提供不同的功能，不同的插件本身的配置比较多样化。</p>
<p>社区中有很多 webpack 插件可供使用，而优秀的插件基本上都提供了详细的使用说明文档。更多的插件可以在这里查找：plugins in awesome-webpack。</p>
<p>下面通过介绍几个常用的插件来了解插件的使用方法。</p>
<h3 id="DefinePlugin"><a href="#DefinePlugin" class="headerlink" title="DefinePlugin"></a>DefinePlugin</h3><p>属于内置插件,可以使用webpack.DefinePlugin直接获取</p>
<p><strong>作用</strong></p>
<p>这个插件用于创建一些在编译时可以配置的全局常量，这些常量的值我们可以在 webpack 的配置中去指定</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">  plugins: [</span><br><span class="line">    new webpack.DefinePlugin(&#123;</span><br><span class="line">      PRODUCTION: JSON.stringify(true), &#x2F;&#x2F; const PRODUCTION &#x3D; true</span><br><span class="line">      VERSION: JSON.stringify(&#39;5fa3b9&#39;), &#x2F;&#x2F; const VERSION &#x3D; &#39;5fa3b9&#39;</span><br><span class="line">      BROWSER_SUPPORTS_HTML5: true, &#x2F;&#x2F; const BROWSER_SUPPORTS_HTML5 &#x3D; &#39;true&#39;</span><br><span class="line">      TWO: &#39;1+1&#39;, &#x2F;&#x2F; const TWO &#x3D; 1 + 1,</span><br><span class="line">      CONSTANTS: &#123;</span><br><span class="line">        APP_VERSION: JSON.stringify(&#39;1.1.2&#39;) &#x2F;&#x2F; const CONSTANTS &#x3D; &#123; APP_VERSION: &#39;1.1.2&#39; &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<hr>
<h2 id="更好地使用-webpack-dev-server"><a href="#更好地使用-webpack-dev-server" class="headerlink" title="更好地使用 webpack-dev-server"></a>更好地使用 webpack-dev-server</h2><p>在构建带吧并部署到生产环境之前，我们需要一个本地环境，用于运行我们开发的代码。这个环境相当于提供了一个简单的服务器，用于访问webpack构建好的静态文件，我们日常开发可以使用它来调试前端代码。</p>
<h3 id="webpack-dev-server-的基础使用"><a href="#webpack-dev-server-的基础使用" class="headerlink" title="webpack-dev-server 的基础使用"></a>webpack-dev-server 的基础使用</h3><p>webpack-dev-server 是一个 npm package，安装后在已经有 webpack 配置文件的项目目录下直接启动就可以</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack-dev-server -g</span><br><span class="line">webpack-dev-server --mode development</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="https://lizheguang.github.io/2018/07/13/%E6%8E%98%E9%87%91-webapck/" data-id="ckcjwflve00080f97867cddv1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/mongoose-%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91/" rel="tag">mongoose 文档翻译</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/mongoose-%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91/" style="font-size: 10px;">mongoose 文档翻译</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/02/15/hello-world/">类数组对象</a>
          </li>
        
          <li>
            <a href="/2019/02/15/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B/">TCP三次握手与四次握手</a>
          </li>
        
          <li>
            <a href="/2019/02/15/%E7%B1%BB%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1/">类数组对象</a>
          </li>
        
          <li>
            <a href="/2018/12/17/node%E9%9D%A2%E8%AF%95/">node面试</a>
          </li>
        
          <li>
            <a href="/2018/09/27/%E4%BA%91%E5%BC%80%E5%8F%91%E5%88%9D%E6%8E%A2/">云开发初探</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>